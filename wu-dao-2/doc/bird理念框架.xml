<?xml version="1.0" encoding="UTF-8"?>

<bird理念框架 version="0.31">
	<理念的理念>
		理念指导和引导技术, 技术体现和展现理念
	</理念的理念>
	<隐约目标>推动软件生命化进程</隐约目标>
	<创新理念>
		<天天新观点>
			<name>ODOT</name>
			<content>One Day, One Thought!</content>
			<description>
				如果每天都有一个新想法, 那么累计起来就会有更多更新的想法. Day是一个周期的概念, Day 可以是
				Year, Month, 也可以是 Hour, Minute, Second
			</description>
		</天天新观点>
		<提高>
			有所发现, 有所突破, 有所创新, 有所超越
		</提高>
	</创新理念>
	<时间理念>
		run with time.
	</时间理念>
	<开发理念>
		<人机协作>
			<name>HCWT</name>
			<content>Human Computer Work Together</content>
			<description>
				在开发过程中充分进行人机协作, 机器擅长重复性的工作, 人擅长于提炼出这种重复性的工作; 为此,
				好的方式是:人把相同的东西提炼出来, 剩下的工作让机器完成.
			</description>
		</人机协作>
		<开发流程>
			idea-->pioneer-->pave-->open
			用例-->测试用例-->测试用例数据-->编码-->走查-->调试-->运行-->OPDC检查-->重构-->OPDC检查-->重构-->OPDC检查-->设计-->编码-->提交			
		</开发流程>
		<开发流程>
			开路-->铺路-->通车-->运货
		</开发流程>
		
		<开发意识>
			使它运行-->使它正确-->使它更满意
		</开发意识>
		<导向>
			最清楚, 最明白, 最简单, 最容易
		</导向>
	</开发理念>
	<设计理念>
		<六个什么>
			<name>6What</name>
			<content>要什么, 有什么;有什么, 用什么; 缺什么, 造什么.</content>
			<description>
				客户希望的就是：我要什么, 你就提供什么. 对于开发人员来说, 客户要的可能有, 也可能没有, 在设计过程中,
				客户要什么, 就设计什么, 对于有的我们就用, 对于没有的我们就造. 总之一句话：一切以客户为中心.
				(注意：这里有一个前提, 可行性已经得到了验证)
			</description>
		</六个什么>
		<组件间的组合方式>
			<命令方式>归属, 直接使用, 包含</命令方式>
			<请求方式>协作, 通信交互, 独立</请求方式>
		</组件间的组合方式>
		<结构化>
			<数据结构化>
			</数据结构化>
			<处理结构化>
			</处理结构化>
		</结构化>
	</设计理念>
	<编码理念>
		<编码风格>
			<up-style>
				观察--指挥：急
			</up-style>
			<down-style>
				上报--指挥：稳(通过事件机制来实现)
			</down-style>
		</编码风格>
		<编码核心>尽量使代码独立自主, 减少人工干预</编码核心>
		<编码流程>
			<name>CIDR</name>
			<content>
				推荐的编码流程是:编码(Code)-->走查(Inspection)-->调试(Debug)-->运行(Run)
			</content>
			<description>
				按这个过程进行编码, 那么获得的将是激动与兴奋, 以及高质量; 如果不按此顺序获得的将是挫折与痛苦,
				以及低质量.
			</description>
		</编码流程>
		<重构>
			<name>PCMM</name>
			<content>编程能力成熟度模型</content>
			<description>
				PCMM是模仿CMM的产物, 但CMM关注项目, 而是PCMM关注的是底层代码. PCMM指明了代码重构的方向,
				代码从最低级到更高级的进行重构.
			</description>
			<detail>
				<试探级>
					<关注>可行性</关注>
					<核心思想>可行性是前提</核心思想>
					<思考单位>语句</思考单位>
					<说明>
						在不确定的时候都会写一些试探级的代码, 毕竟人的知识和记忆力是有限,
						比如：想验证某个正则表达式是否能匹配, \s能否匹配中文的空格
					</说明>
				</试探级>
				<分解级>
					<关注>灵活性, 可读性</关注>
					<核心思想>先把要做到分解到自己的能力范围内, 然后开始动手</核心思想>
					<思考单位>函数, 过程</思考单位>
					<说明>
						当代码的可行性得到验证, 那么就会有新的追求了, 试探级的代码一般写在一个main函数里,
						这样修改起来很不方便, 而且读起来也很费力. 如将这些代码分解到几个函数里,
						然后在main里面调用, 这样看起来就舒服多了.
					</说明>
				</分解级>
				<提炼级>
					<关注>复用性</关注>
					<核心思想>共性让我来处理, 个性让你来展现</核心思想>
					<思考单位>实用包, 模板, 框架, 接口</思考单位>
					<说明>
						当对分解级代码进行审查时, 可能又有新的追求了: 我辛辛苦苦写的这些代码可不可以以后再次使用.
						比如: 写好了一个获取bean里field字段的get或set方法, 然后把它提炼出来,
						写进实用包中, 下次使用时, 直接调用就行, 就没有必要每次都去重写这个方法;
						写好了一个对于某个目录下的所有java文件进行编码转换(gbk-->utf-8),
						然后提炼一个针对树形结构的遍历模板, 写进实用包中, 下遇到这种树形结构的,
						只须关心对节点怎么处理, 不用去管怎么去遍历这个树形结构了;
						把用户不关心的那部分提炼出来形成框架, 把用户关心的那部分留个用户.
					</说明>
					<复用级别>
						<在方法内部复用>过程</在方法内部复用>
						<在方法之间复用>函数</在方法之间复用>
						<在类内部复用>公共方法</在类内部复用>
						<在类之间复用>公共类</在类之间复用>
						<在模块内部复用>实用包</在模块内部复用>
						<在模块之间复用>模板</在模块之间复用>
						<在项目内部复用>接口</在项目内部复用>
						<在项目之间复用>框架</在项目之间复用>
					</复用级别>
				</提炼级>
				<独立级>
					<关注>通用性</关注>
					<核心思想>它不属于任何语言,任何平台,任何系统, 它就是一个独立的概念</核心思想>
					<思考单位>类, 组件, 数据结构, 接口, 文件格式</思考单位>
					<说明>
						能复用的代码不一定通用, 下一追求就是通用性,
						如果我的写一段代码,所有的程序员就可以少写这一段重复的代码,那么将是多么具有成就感的工作.
					</说明>
					<独立级别>
						<独立于语言>数据结构, 算法</独立于语言>
						<独立于平台>标记语言</独立于平台>
						<独立于系统>软硬件系统</独立于系统>
					</独立级别>
				</独立级>
				<用户级>
					<关注>易学性,易用性</关注>
					<核心思想>你给用户越多, 用户给你的也越多</核心思想>
					<思考单位>用户的身心动作</思考单位>
					<说明>
						最后不要忘了, 所有代码都是服务于客户的, 我们的终极目标是客户,
						这时就考虑用户是怎么使用代码的, 怎么才能更容易学习, 更容易使用, 以便发挥代码的最大价值.
					</说明>
				</用户级>
				<复用角度>
					<分解级>在它之内复用</分解级>
					<提炼级>在它们之间复用</提炼级>
					<独立级>在所有之间复用</独立级>
					<它>函数, 方法, 类, 包, 模块, 组件, 系统</它>
				</复用角度>
				<通用角度>
					<通用于各种语言>数据结构, 算法</通用于各种语言>
					<通用于各类平台></通用于各类平台>
					<通用于各类系统></通用于各类系统>
				</通用角度>
			</detail>
		</重构>
		<bug>
			<name>From KC(Knowledge Consciousness)</name>
			<content>
				<bug来源>
					<知识层>
						<不知道>
							对某个知识不知道, 比如：oracle的菜单表中insert一条菜单地址,
							如果包含&amp;(请求参数连接符)就需要用&amp;&amp;(连续两个&amp;),
							因为对这个知识不了解使每次初始化数据库后都找不到页面
						</不知道>
						<忽略>
							对某个知识知道, 但是编码时忽略了, 比如:java中double型最多15位,
							超过15就会有精度丢失, 那么input type="text"
							的maxLength应该是15
						</忽略>
					</知识层>
					<意识层>
						<条件>
							<假设的条件>
								编码时会有意无意的加上一些假设, 比如：假设配置文件存在,
								假设数据库中某种字段存在, 假设用户不会输入这么不合法的数据
							</假设的条件>
						</条件>
						<结果>
							<想当然的结果>
								编码时也会有意无意的加上一些想当然的结果, 比如我：代码都是从那边copy的,
								那边没问题,那么我这里就没问题; 但是我忘了两边有不一致的.
							</想当然的结果>
						</结果>
						<心理>
							<侥幸心理>在这个应用中应该不可能出现这种情况</侥幸心理>
						</心理>
					</意识层>
				</bug来源>
				<bug对策>
					<知识层>这里没什么好说的, 只能靠自己多学,多看,多练习,多积累</知识层>
					<意识层>
						<条件>
							<真实的条件>条件应该尽可能的是真实可信的基础上</真实的条件>
							<假设的条件>在没有真实条件时, 那么假设的条件至少建立在合理的基础上</假设的条件>
						</条件>
						<结果>
							<实践的结果>结果应该尽可能的是实践得出的结果</实践的结果>
							<推理的结果>
								在没有实践结果的前提下, 至少是正确前提加上正确的推理而得到结果
							</推理的结果>
							<想当然的结果>应该避免想当然的结果</想当然的结果>
						</结果>
						<心理>
							<严谨心理>
								可能有bug, 那么一定就会出bug; 现在不出bug, 以后都会出不过.
							</严谨心理>
						</心理>
					</意识层>
				</bug对策>
				<bug案例分析>
					<案例 index="1">
						<情况>新增或修改代码没有进行测试</情况>
						<bug来源分析>意识层.假设的条件：中间步骤就是最终结果</bug来源分析>
						<建议>
							新增或修改代码后进行全部测试, 至少应该对其影响的部分进行反测, 如果影响过大,
							就需要全部测试.
						</建议>
					</案例>
				</bug案例分析>
			</content>
		</bug>
		<内核编码>
			<name>内核编码</name>
			<content>
				<合理的假设>bug被发现的可能性与它被使用的次数和多样性成正比.</合理的假设>
				<推荐>
					编写一个强大的内核, 所有的应用都调用它, 这样在多次使用中能, 最大可能的独立bug和发现bug.
				</推荐>
			</content>
		</内核编码>
	</编码理念>
	<测试理念-woodpecker>
		<完美_缺陷>
			<name>OPDC</name>
			<content>Orthogonal Perfect Defect Classification</content>
			<description>
				在培训ODC时, 就感觉到ODC的庞大与复杂, 虽然听上去很有用；在太钢项目中除了正确填填odc属性外,
				好像都没怎么用. ODC指出了错误的, 但是没有明确指出正确的. OPDC很简单, 但很实用,
				并且指出了什么是Perfect, 什么是Defect.
			</description>
			<detail>
				<目标>100%Perfect, 0%Defect</目标>
				<结构>
					<需求中>
						<完美>
							<情景一>规则满足 AND 功能提供</情景一>
							<情景二>规则不满足 AND 功能不提供</情景二>
						</完美>
						<缺陷>
							<情景一>规则满足 AND 功能不提供</情景一>
							<情景二>规则不满足 AND 功能提供</情景二>
						</缺陷>
					</需求中>
					<运行中>
						<完美>
							<情景一>反馈成功 AND 期望满足</情景一>
							<情景二>反馈不成功 AND 期望满足</情景二>
						</完美>
						<缺陷>
							<情景一>反馈成功 AND 期望不满足</情景一>
							<情景二>反馈不成功 AND 期望不满足</情景二>
						</缺陷>
						<注释>操作成功的反馈期望：输入==存储==显示;操作失败的反馈期望：指出违反什么规则</注释>
					</运行中>
				</结构>
				<计划>
					<第一步>对所有调用方法的对象进行空指针检查</第一步>
					<第二步>对所有传入参数进行有效性检查</第二步>
					<第三步>对所有的进行OPDC检查</第三步>
				</计划>
			</detail>
		</完美_缺陷>
	</测试理念-woodpecker>
	
	<零星理念>
		<调皮的代码>
			根据什么判断代码是按期望的运行的
		
			1, 根据走查结果
			2, 根据调试结果
			3, 根据运行结果
			4, 根据推理+分析
			5, 根据经验, 曾经我运行过这样的代码, 当时它的结果是那样的, 现在也应该是那样

			以上5条都是人工干涉的的情况下进行的, 如何让代码来做这些事啦, 是一个值得思考的问题.
			
			
			总希望代码像我们想象的那样运行,
			其实不然,
			太多的偶然因素,
			太多的人为因素,
			使代码不能像我想象的那样运行
			
			如果能尽可能的减少人为因素, 偶然因素,
			代码将尽可能的像我们想象的那样运行
		
		</调皮的代码>
		<走查能发现的错误>
			走查查什么
			1, 代码存在, 资源存在
			2, 整合起来的文件存在并正确
			3, 运行起来的代码是存在并正确
			4, 逻辑判断, 程序是按逻辑判断的分支执行的
			<实际例子>
				<存在>程序需要的资源不存在了, 走查时可以发现</存在>
				<不一致> 一次在走查中发现了一个映射不正确bug,  源于copy代码时, 只修改了中文的, 没有改英文
				</不一致>
			</实际例子>
		</走查能发现的错误>
		<数据>
			基础数据, 业务数据, 抽取挖掘数据
		</数据>
		<处理>
			手动任务, 自动任务, 机器任务
			单处理, 批处理
		</处理>
		
		<数据与操作>
			将数据与操作分离的一种方法是：操作是针对某一数据结构的操作。
			将要处理的数据组织到一种结构之中去，然后开发一种针对这种结构的操作。
			最后的结果是：只要能符合这种结构，程序都能处理。大大增加了灵活性，扩展性。
		</数据与操作>
		<实体>
			组成-->结构-->功能-->机理-->行为-->状态-->外观
			行为是按某种刺激下表现出来的 状态变化，
			刺激有两种：恒定和突发的；如果地球引力就是恒定刺激，而被雷击了就是偶然刺激。
			
			行为是在某一环境下的行为， 当环境变化后，行为也跟随变化。
			一个实体在不同的环境下为它制定不同的行为。
			外界为我们提供一个环境，我们一方面受限于环境，另一方面我们改变环境。
			
			在环境下形成行为，如果在某种环境下没有形成行为，那么就没有行为。
		</实体>
		
		<记录>
			状态
			特征
			
			元素
			空间结构
			时空结构
		</记录>
		<流程>
			需求文档
			
			现在的需求，将来的需求
			表达出来的需求，没有表达出来的需求
						
			设计文档
			
			1，数据的存储
			2，数据处理
			3，数据展现
		</流程>
	</零星理念>
</bird理念框架>